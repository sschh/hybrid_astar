/******************************************************************************

/**
 * @file
 * @brief Defines the EcarxLatController class.
 */

#ifndef MODULES_CONTROL_CONTROLLER_ECARX_MPC_CONTROLLER_H_
#define MODULES_CONTROL_CONTROLLER_ECARX_MPC_CONTROLLER_H_

#include <fstream>
#include <memory>
#include <string>


namespace HybridAStar {
namespace control {

/**
 * @class MPCController
 *
 * @brief MPCController, combined lateral and logitudinal controllers
 */
 
class EcarxLatController: public Controller{
 public:
  /**
   * @brief constructor
   */
  EcarxLatController();

  /**
   * @brief destructor
   */
  virtual ~EcarxLatController();

  /**
   * @brief initialize MPC Controller
   * @param control_conf control configurations
   * @return Status initialization status
   */
  common::Status Init(const ControlConf *control_conf) override;

  /**
   * @brief compute steering target and throttle/ brake based on current vehicle
   * status and target trajectory
   * @param localization vehicle location
   * @param chassis vehicle status e.g., speed, acceleration
   * @param trajectory trajectory generated by planning
   * @param cmd control command
   * @return Status computation status
   */
  common::Status ComputeControlCommand(
      const localization::LocalizationEstimate *localization,
      const float *path_speed, const planning::ADCTrajectory *trajectory,
      ControlCommand *cmd) override;

  /**
   * @brief reset MPC Controller
   * @return Status reset status
   */
  common::Status Reset() override;

  /**
   * @brief stop MPC controller
   */
  void Stop() override;

  /**
   * @brief MPC controller name
   * @return string controller name in string
   */
  std::string Name() const override;

 protected:
  void UpdateState(SimpleMPCDebug *debug);

  void UpdateMatrix(SimpleMPCDebug *debug);

  void FeedforwardUpdate(SimpleMPCDebug *debug);

  void ComputeLateralErrors(const double x, const double y, const double theta,
                            const double linear_v, const double angular_v,
                            const TrajectoryAnalyzer &trajectory_analyzer,
                            SimpleMPCDebug *debug);

  void ComputeLongitudinalErrors(const TrajectoryAnalyzer *trajectory);

  bool LoadControlConf(const ControlConf *control_conf);

  void InitializeFilters(const ControlConf *control_conf);

  void LogInitParameters();

  void CloseLogFile();

  // vehicle parameter
  //common::VehicleParam vehicle_param_;

  // a proxy to analyze the planning trajectory
  //TrajectoryAnalyzer trajectory_analyzer_;

  void LoadControlCalibrationTable(const MPCControllerConf &mpc_controller_conf);

  void LoadMPCGainScheduler(const MPCControllerConf &mpc_controller_conf);

  std::unique_ptr<Interpolation2D> control_interpolation_;

  // the following parameters are vehicle physics related.
  // control time interval
  double ts_ = 0.0;
  // distance between front and rear wheel center
  double wheelbase_ = 0.0;
  // the ratio between the turn of the steering wheel and the turn of the wheels
  double steer_transmission_ratio_ = 0.0;
  // the maximum turn of steer

  // number of states, includes
  // lateral error, lateral error rate, heading error, heading error rate,
  // station error, velocity error,
  const int basic_state_size_ = 6;
  const int controls_ = 2;
  const int horizon_ = 10;

  // heading error of last control cycle
  double previous_heading_error_ = 0.0;
  // lateral distance to reference trajectory of last control cycle
  double previous_lateral_error_ = 0.0;

  // parameters for mpc solver; number of iterations
  int mpc_max_iteration_ = 0;
  // parameters for mpc solver; threshold for computation
  double mpc_eps_ = 0.0;


  // for logging purpose
  std::ofstream mpc_log_file_;

  const std::string name_;

  double standstill_acceleration_ = 0.0;

  double throttle_deadzone_ = 0.0;

  double brake_deadzone_ = 0.0;

  double steer_angle_feedforwardterm_ = 0.0;

  double steer_angle_feedforwardterm_updated_ = 0.0;

  double max_acceleration_ = 0.0;
  

  double max_deceleration_ = 0.0;

  double beta_lon_speed=0;
	int iter_times_max=0;
	double beta_lon_position=0;
	double beta_lon_acc=0;
	double beta_lon_acc_com=10;
	double lon_acc_delay=0.3;
	double Acc_max=3;
	double Acc_min=-5;
	double Steer_Ratio=30;
	double beta_head_angle_error=1;
	double beta_Lat_position_error=28;
	double beta_Wheel_angle=0;
	double beta_Wheel_angle_com=30;
	double Wheelbase_f=1;
	double Wheelbase_r=1.85;
	double Wheel_angle_delay=0.4;
	double Wheel_angle_change_rate_max=0.3;
	double time_interval=0.1;
  int omit_step_lat = 30;
  int omit_step_heading_angle = -1;
  int omit_step_lon = -1;
  int omit_step_speed = -1;
  double steering_rate=30; 
  double throttle=35;

  double current_trajectory_timestamp_ = -1.0;

  double init_vehicle_x_ = 0.0;

  double init_vehicle_y_ = 0.0;

  double init_vehicle_heading_ = 0.0;
  
  double minimum_speed_protection_ = 0.1;
};

}  // namespace 
}  // namespace HybridAStar

#endif  // MODULES_CONTROL_CONTROLLER_MPC_CONTROLLER_H_
